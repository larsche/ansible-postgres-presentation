---
- name: force remove folder
  file:
     path: "{{ postgresql_data_dir }}.old/"
     state: absent

- name: Slave | Check if old folder exsists
  stat:
    path: "{{ postgresql_data_dir }}.old/"  
  register: slave_old_dir 

- debug: var=pgrecovery_check

- name: Slave set up | stop postgres if running 
  service:
    name: postgresql@{{ postgres_version }}-main
    state: stopped
  register: stopping_slave
  when: not pgrecovery_check.stat.exists
        or force_slave is defined

- name: Slave | move the the old folder
  command: "mv {{ postgresql_data_dir }} {{ postgresql_data_dir }}.old/"
  register: move_old_folder
  when: (not slave_old_dir.stat.exists and not pgrecovery_check.stat.exists) or force_slave

- name: Slave | create slave
  become: true
  become_user: postgres
  shell: "export PGPASSWORD={{ replicant_pwd }} && /usr/lib/postgresql/{{ postgres_version }}/bin/pg_basebackup -h {{ primary }} -U {{ replicant_user }} -P  -R -X s -D /var/lib/postgresql/{{ postgres_version }}/main 2>&1 "
  when: move_old_folder.changed 
  register: create_slave
  # async: 1000
  # poll: 0
  # register: backup_sleeper
  vars:
    ansible_ssh_pipelining: true

    #- name: Slave | check progress 
    #  async_status:
    #    jid: "{{ backup_sleeper.ansible_job_id }}"
    #  register: job_result
    #  until: job_result.finished
    #  retries: 30

- name: Slave | create recovery file
  template:
    src: recovery.conf.j2
    dest: "{{ postgresql_data_dir }}/recovery.conf"
    owner: "{{ postgresql_user }}"
    group: "{{ postgresql_group }}"
  notify: restart postgresql
  when: create_slave is succeeded


- name: slave | remove the main.old folder
  file:
    path: "{{ postgresql_data_dir }}.old/"
    state: absent
  when: (create_slave is succeeded or create_slave is not skipped) and move_old_folder.changed
  




          
